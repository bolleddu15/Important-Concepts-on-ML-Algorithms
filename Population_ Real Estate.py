# -*- coding: utf-8 -*-
"""mth522(proj3).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uwYm00Pi9fTNu5z2T84jHa7iXvhEZTbp
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

"""# **EDA Process**"""

#running the dataset
df=pd.read_csv("/content/fy2023-property-assessment-data.csv")
print(df)

df.describe()

df.head()

column_names = df.columns.tolist()
print(column_names)

num_columns = len(column_names)
print("Number of columns:", num_columns)

"""Metrics used to classify the Problem ?

**Prediction Analysis ?**
* Linear regression over - Predicting numerical values like 'TOTAL_VALUE,' 'LAND_VALUE,' or 'GROSS_TAX.

**Classification Analysis ?**
* 'HEAT_TYPE', 'ROOF_STRUCTURE', 'EXT_COND': Features describing different property characteristics that could lead to classifications

"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt

# Load the dataset
file_path = '/content/fy2023-property-assessment-data.csv'
data = pd.read_csv(file_path)

# Selecting predictor variables
predictor_columns = [
    'LAND_SF', 'LIVING_AREA', 'YR_BUILT', 'YR_REMODEL', 'NUM_BLDGS',
    'RES_UNITS', 'COM_UNITS', 'RC_UNITS', 'FULL_BTH', 'HLF_BTH',
    'BED_RMS', 'FIREPLACES', 'NUM_PARKING'
]

# Handling missing values - filling with median
data[predictor_columns] = data[predictor_columns].fillna(data[predictor_columns].median())

# Defining the target variable
target = 'TOTAL_VALUE'

# Splitting the dataset into training and testing sets
X = data[predictor_columns]
y = data[target]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Creating and training the linear regression model
model = LinearRegression()
model.fit(X_train, y_train)

# Predicting and evaluating the model
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
# Plotting actual vs predicted values
plt.figure(figsize=(10,6))
plt.scatter(y_test, y_pred, alpha=0.5)  # Plotting the actual vs predicted values
plt.xlabel('Actual Values')  # Label for the x-axis
plt.ylabel('Predicted Values')  # Label for the y-axis
plt.title('Actual vs Predicted Values')  # Title of the plot
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)  # Diagonal line
plt.show()  # Display the plot


# Displaying the results
print("Mean Squared Error:", mse)
print("R-squared:", r2)


mse = 68057966471224.44
r2 = 0.6865944426599158

# Values for MSE and R-squared
metrics = {'Mean Squared Error': mse, 'R-squared': r2}

# Creating a bar chart
plt.figure(figsize=(8, 4))
plt.bar(metrics.keys(), metrics.values(), color=['blue', 'green'])
plt.title('Model Evaluation Metrics')  # Title of the chart
plt.ylabel('Value')  # Label for the y-axis
plt.show()  # Display the plot

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns


file_path = '/content/fy2023-property-assessment-data.csv'
data = pd.read_csv(file_path)


relevant_columns = ['YR_BUILT', 'INT_COND', 'EXT_FNISHED', 'ROOF_COVER', 'YR_REMODEL']
data_relevant = data[relevant_columns]


data_relevant.dropna(inplace=True)


label_encoders_updated = {}
for column in ['INT_COND', 'EXT_FNISHED', 'ROOF_COVER']:
    le_updated = LabelEncoder()
    data_relevant[column] = le_updated.fit_transform(data_relevant[column])
    label_encoders_updated[column] = le_updated


X_updated = data_relevant.drop('YR_REMODEL', axis=1)
y_updated = data_relevant['YR_REMODEL']


y_updated = (y_updated > 2000).astype(int)

# Splitting the dataset into training and testing sets
X_train_updated, X_test_updated, y_train_updated, y_test_updated = train_test_split(X_updated, y_updated, test_size=0.3, random_state=42)

# Building the Random Forest Classifier
rf_classifier_updated = RandomForestClassifier(n_estimators=100, random_state=42)
rf_classifier_updated.fit(X_train_updated, y_train_updated)

# Predicting on the test set
y_pred_updated = rf_classifier_updated.predict(X_test_updated)

# Evaluating the model
accuracy_updated = accuracy_score(y_test_updated, y_pred_updated)
print(f"Accuracy of the model: {accuracy_updated:.2f}")


print("\nClassification Report:\n", classification_report(y_test_updated, y_pred_updated))

# Confusion Matrix
cm = confusion_matrix(y_test_updated, y_pred_updated)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt="d", cmap='Blues')
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('True')
plt.show()

"""Classification Algo"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report

# Load the dataset
data = pd.read_csv('/content/fy2023-property-assessment-data.csv')
columns_to_check = ['BED_RMS', 'FULL_BTH', 'LIVING_AREA', 'YR_BUILT', 'LAND_SF']

# Remove rows with null values in the specified columns
data.dropna(subset=columns_to_check, inplace=True)

# Define the luxury criterion (simplified example)
data['luxury'] = ((data['BED_RMS'] > 4) & (data['FULL_BTH'] > 3) & (data['LIVING_AREA'] > 3000)).astype(int)

# Prepare the data for training
X = data[['BED_RMS', 'FULL_BTH', 'LIVING_AREA', 'YR_BUILT', 'LAND_SF']]
y = data['luxury']

# Split the dataset into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize and train the classifier
clf = RandomForestClassifier(random_state=42)
clf.fit(X_train, y_train)

# Predict on the test set
y_pred = clf.predict(X_test)

# Calculate accuracy and display the classification report
accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)

print("Accuracy:", accuracy)
print("Classification Report:\n", report)

##Plotting the street and avg cost per street
import matplotlib.pyplot as plt
import pandas as pd

missing_values = data[['ST_NAME', 'TOTAL_VALUE']].isnull().sum()
mean_values = data.groupby('ST_NAME')['TOTAL_VALUE'].mean().reset_index()

plt.figure(figsize=(20, 10))
sample_data = mean_values.sample(n=50, random_state=1)  # Taking a random sample of 50 streets

plt.bar(sample_data['ST_NAME'], sample_data['TOTAL_VALUE'])
plt.xticks(rotation=90)
plt.title('Mean Total Property Value by Street')
plt.xlabel('Street Name')
plt.ylabel('Mean Total Value')

plt.tight_layout()
plt.show()

##Distribution of Property Types
import matplotlib.pyplot as plt

property_types = ['Residential Condos', 'Single Family Dwellings', 'Two-Family Dwellings', 'Three-Family Dwellings', 'Condo Main']
counts = [70558, 30442, 16903, 13346, 10541]

plt.figure(figsize=(10, 6))
plt.bar(property_types, counts, color='skyblue')
plt.title('Distribution of Property Types')
plt.xlabel('Property Type')
plt.ylabel('Number of Properties')
plt.xticks(rotation=45, ha="right")
plt.tight_layout()
plt.show()

##Comparison of Average Living Area and Land Size by Property Type
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

data = pd.read_csv('/content/fy2023-property-assessment-data.csv')
average_sizes_by_type = data.groupby('LU_DESC')[['LIVING_AREA', 'LAND_SF']].mean()

# Sorting the results by average living area for better visualization
average_sizes_sorted = average_sizes_by_type.sort_values(by='LIVING_AREA', ascending=False)
top_10 = average_sizes_sorted.head(10)


plt.figure(figsize=(15, 10))
sns.barplot(x=top_10['LIVING_AREA'], y=top_10.index, color='blue', label='Living Area')
sns.barplot(x=top_10['LAND_SF'], y=top_10.index, color='orange', alpha=0.6, label='Land Size')
plt.xlabel('Size in Square Feet')
plt.ylabel('Property Type')
plt.title('Comparison of Average Living Area and Land Size by Property Type')
plt.legend()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

data = pd.read_csv('/content/fy2023-property-assessment-data.csv')
average_value_by_zip = data.groupby('ZIP_CODE')['TOTAL_VALUE'].mean()
average_value_sorted = average_value_by_zip.sort_values(ascending=False)

plt.figure(figsize=(15, 10))
sns.barplot(x=average_value_sorted.values, y=average_value_sorted.index.astype(str))

# Adding labels and title
plt.xlabel('Average Property Value (in 100 millions)')
plt.ylabel('Zip Code')
plt.title('Average Property Value Distribution by Zip Code')

# Display the plot
plt.show()